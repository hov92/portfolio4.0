import { ParticlesOptions } from "../Options/Classes/Particles/ParticlesOptions";
import { Shape } from "../Options/Classes/Particles/Shape/Shape";
import { AlterType, AnimationStatus, DestroyMode, OutMode, RotateDirection, StartValueType, TiltDirection, } from "../Enums";
import { clamp, colorToHsl, colorToRgb, deepExtend, getDistance, getHslAnimationFromHsl, getHslFromAnimation, getParticleBaseVelocity, getParticleDirectionAngle, getRangeMax, getRangeMin, getRangeValue, getValue, isInArray, itemFromArray, Plugins, randomInRange, setRangeValue, } from "../Utils";
import { Vector } from "./Particle/Vector";
import { Vector3d } from "./Particle/Vector3d";
export class Particle {
    constructor(id, container, position, overrideOptions, group) {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;
        this.id = id;
        this.container = container;
        this.group = group;
        this.fill = true;
        this.close = true;
        this.lastPathTime = 0;
        this.destroyed = false;
        this.unbreakable = false;
        this.splitCount = 0;
        this.misplaced = false;
        this.maxDistance = {};
        const pxRatio = container.retina.pixelRatio;
        const options = container.actualOptions;
        const particlesOptions = new ParticlesOptions();
        particlesOptions.load(options.particles);
        const shapeType = particlesOptions.shape.type;
        const reduceDuplicates = particlesOptions.reduceDuplicates;
        this.shape = shapeType instanceof Array ? itemFromArray(shapeType, this.id, reduceDuplicates) : shapeType;
        if (overrideOptions === null || overrideOptions === void 0 ? void 0 : overrideOptions.shape) {
            if (overrideOptions.shape.type) {
                const overrideShapeType = overrideOptions.shape.type;
                this.shape =
                    overrideShapeType instanceof Array
                        ? itemFromArray(overrideShapeType, this.id, reduceDuplicates)
                        : overrideShapeType;
            }
            const shapeOptions = new Shape();
            shapeOptions.load(overrideOptions.shape);
            if (this.shape) {
                this.shapeData = this.loadShapeData(shapeOptions, reduceDuplicates);
            }
        }
        else {
            this.shapeData = this.loadShapeData(particlesOptions.shape, reduceDuplicates);
        }
        if (overrideOptions !== undefined) {
            particlesOptions.load(overrideOptions);
        }
        if (((_a = this.shapeData) === null || _a === void 0 ? void 0 : _a.particles) !== undefined) {
            particlesOptions.load((_b = this.shapeData) === null || _b === void 0 ? void 0 : _b.particles);
        }
        this.fill = (_d = (_c = this.shapeData) === null || _c === void 0 ? void 0 : _c.fill) !== null && _d !== void 0 ? _d : this.fill;
        this.close = (_f = (_e = this.shapeData) === null || _e === void 0 ? void 0 : _e.close) !== null && _f !== void 0 ? _f : this.close;
        this.options = particlesOptions;
        const zIndexValue = getRangeValue(this.options.zIndex.value);
        this.pathDelay = getValue(this.options.move.path.delay) * 1000;
        this.wobbleDistance = 0;
        container.retina.initParticle(this);
        const sizeOptions = this.options.size;
        const sizeValue = getValue(sizeOptions) * container.retina.pixelRatio;
        const sizeRange = sizeOptions.value;
        this.size = {
            enable: sizeOptions.animation.enable,
            value: sizeValue,
            max: getRangeMax(sizeRange) * pxRatio,
            min: getRangeMin(sizeRange) * pxRatio,
            loops: 0,
            maxLoops: sizeOptions.animation.count,
        };
        const sizeAnimation = sizeOptions.animation;
        if (sizeAnimation.enable) {
            this.size.status = AnimationStatus.increasing;
            switch (sizeAnimation.startValue) {
                case StartValueType.min:
                    this.size.value = this.size.min;
                    this.size.status = AnimationStatus.increasing;
                    break;
                case StartValueType.random:
                    this.size.value = randomInRange(this.size) * pxRatio;
                    this.size.status = Math.random() >= 0.5 ? AnimationStatus.increasing : AnimationStatus.decreasing;
                    break;
                case StartValueType.max:
                default:
                    this.size.value = this.size.max;
                    this.size.status = AnimationStatus.decreasing;
                    break;
            }
            this.size.velocity =
                (((_g = this.sizeAnimationSpeed) !== null && _g !== void 0 ? _g : container.retina.sizeAnimationSpeed) / 100) *
                    container.retina.reduceFactor;
            if (!sizeAnimation.sync) {
                this.size.velocity *= Math.random();
            }
        }
        this.direction = getParticleDirectionAngle(this.options.move.direction);
        this.bubble = {
            inRange: false,
        };
        this.initialVelocity = this.calculateVelocity();
        this.velocity = this.initialVelocity.copy();
        const rotateOptions = this.options.rotate;
        this.rotate = {
            enable: rotateOptions.animation.enable,
            value: (getRangeValue(rotateOptions.value) * Math.PI) / 180,
        };
        let rotateDirection = rotateOptions.direction;
        if (rotateDirection === RotateDirection.random) {
            const index = Math.floor(Math.random() * 2);
            rotateDirection = index > 0 ? RotateDirection.counterClockwise : RotateDirection.clockwise;
        }
        switch (rotateDirection) {
            case RotateDirection.counterClockwise:
            case "counterClockwise":
                this.rotate.status = AnimationStatus.decreasing;
                break;
            case RotateDirection.clockwise:
                this.rotate.status = AnimationStatus.increasing;
                break;
        }
        const rotateAnimation = this.options.rotate.animation;
        if (rotateAnimation.enable) {
            this.rotate.velocity = (rotateAnimation.speed / 360) * container.retina.reduceFactor;
            if (!rotateAnimation.sync) {
                this.rotate.velocity *= Math.random();
            }
        }
        const tiltOptions = this.options.tilt;
        this.tilt = {
            enable: tiltOptions.enable,
            value: (getRangeValue(tiltOptions.value) * Math.PI) / 180,
            sinDirection: Math.random() >= 0.5 ? 1 : -1,
            cosDirection: Math.random() >= 0.5 ? 1 : -1,
        };
        let tiltDirection = tiltOptions.direction;
        if (tiltDirection === TiltDirection.random) {
            const index = Math.floor(Math.random() * 2);
            tiltDirection = index > 0 ? TiltDirection.counterClockwise : TiltDirection.clockwise;
        }
        switch (tiltDirection) {
            case TiltDirection.counterClockwise:
            case "counterClockwise":
                this.tilt.status = AnimationStatus.decreasing;
                break;
            case TiltDirection.clockwise:
                this.tilt.status = AnimationStatus.increasing;
                break;
        }
        const tiltAnimation = this.options.tilt.animation;
        if (tiltAnimation.enable) {
            this.tilt.velocity = (tiltAnimation.speed / 360) * container.retina.reduceFactor;
            if (!tiltAnimation.sync) {
                this.tilt.velocity *= Math.random();
            }
        }
        const orbitOptions = particlesOptions.orbit;
        if (orbitOptions.enable) {
            this.orbitRotation = getRangeValue(orbitOptions.rotation.value);
            this.orbitColor = colorToHsl(orbitOptions.color);
        }
        const hslColor = colorToHsl(this.options.color, this.id, reduceDuplicates);
        if (hslColor) {
            this.color = getHslAnimationFromHsl(hslColor, this.options.color.animation, container.retina.reduceFactor);
        }
        const gradient = this.options.gradient instanceof Array ? itemFromArray(this.options.gradient) : this.options.gradient;
        if (gradient) {
            this.gradient = {
                angle: {
                    value: gradient.angle.value,
                    enable: gradient.angle.animation.enable,
                    velocity: (gradient.angle.animation.speed / 360) * container.retina.reduceFactor,
                },
                type: gradient.type,
                colors: [],
            };
            let rotateDirection = gradient.angle.direction;
            if (rotateDirection === RotateDirection.random) {
                const index = Math.floor(Math.random() * 2);
                rotateDirection = index > 0 ? RotateDirection.counterClockwise : RotateDirection.clockwise;
            }
            switch (rotateDirection) {
                case RotateDirection.counterClockwise:
                case "counterClockwise":
                    this.gradient.angle.status = AnimationStatus.decreasing;
                    break;
                case RotateDirection.clockwise:
                    this.gradient.angle.status = AnimationStatus.increasing;
                    break;
            }
            for (const grColor of gradient.colors) {
                const grHslColor = colorToHsl(grColor.value, this.id, reduceDuplicates);
                if (grHslColor) {
                    const grHslAnimation = getHslAnimationFromHsl(grHslColor, grColor.value.animation, container.retina.reduceFactor);
                    const addColor = {
                        stop: grColor.stop,
                        value: grHslAnimation,
                        opacity: grColor.opacity
                            ? {
                                enable: grColor.opacity.animation.enable,
                                max: getRangeMax(grColor.opacity.value),
                                min: getRangeMin(grColor.opacity.value),
                                status: AnimationStatus.increasing,
                                value: getRangeValue(grColor.opacity.value),
                                velocity: (grColor.opacity.animation.speed / 100) * container.retina.reduceFactor,
                            }
                            : undefined,
                    };
                    if (grColor.opacity && addColor.opacity) {
                        const opacityRange = grColor.opacity.value;
                        addColor.opacity.min = getRangeMin(opacityRange);
                        addColor.opacity.max = getRangeMax(opacityRange);
                        const opacityAnimation = grColor.opacity.animation;
                        switch (opacityAnimation.startValue) {
                            case StartValueType.min:
                                addColor.opacity.value = addColor.opacity.min;
                                addColor.opacity.status = AnimationStatus.increasing;
                                break;
                            case StartValueType.random:
                                addColor.opacity.value = randomInRange(addColor.opacity);
                                addColor.opacity.status =
                                    Math.random() >= 0.5 ? AnimationStatus.increasing : AnimationStatus.decreasing;
                                break;
                            case StartValueType.max:
                            default:
                                addColor.opacity.value = addColor.opacity.max;
                                addColor.opacity.status = AnimationStatus.decreasing;
                                break;
                        }
                    }
                    this.gradient.colors.push(addColor);
                }
            }
        }
        const rollOpt = this.options.roll;
        if (rollOpt.enable) {
            if (this.color) {
                if (rollOpt.backColor) {
                    this.backColor = colorToHsl(rollOpt.backColor);
                }
                else if (rollOpt.darken.enable && rollOpt.enlighten.enable) {
                    this.alterType = Math.random() >= 0.5 ? AlterType.darken : AlterType.enlighten;
                    this.alterValue =
                        this.alterType === AlterType.darken ? rollOpt.darken.value : rollOpt.enlighten.value;
                }
                else if (rollOpt.darken.enable) {
                    this.alterType = AlterType.darken;
                    this.alterValue = rollOpt.darken.value;
                }
                else if (rollOpt.enlighten.enable) {
                    this.alterType = AlterType.enlighten;
                    this.alterValue = rollOpt.enlighten.value;
                }
            }
            this.rollAngle = Math.random() * Math.PI * 2;
            this.rollSpeed = getRangeValue(rollOpt.speed) / 360;
        }
        else {
            this.rollAngle = 0;
            this.rollSpeed = 0;
        }
        const wobbleOpt = this.options.wobble;
        if (wobbleOpt.enable) {
            this.wobbleAngle = Math.random() * Math.PI * 2;
            this.wobbleSpeed = getRangeValue(wobbleOpt.speed) / 360;
        }
        else {
            this.wobbleAngle = 0;
            this.wobbleSpeed = 0;
        }
        this.position = this.calcPosition(container, position, clamp(zIndexValue, 0, container.zLayers));
        this.initialPosition = this.position.copy();
        this.offset = Vector.origin;
        const particles = container.particles;
        particles.needsSort = particles.needsSort || particles.lastZIndex < this.position.z;
        particles.lastZIndex = this.position.z;
        this.zIndexFactor = this.position.z / container.zLayers;
        const opacityOptions = this.options.opacity;
        this.opacity = {
            enable: opacityOptions.animation.enable,
            max: getRangeMax(opacityOptions.value),
            min: getRangeMin(opacityOptions.value),
            value: getRangeValue(opacityOptions.value),
            loops: 0,
            maxLoops: opacityOptions.animation.count,
        };
        const opacityAnimation = opacityOptions.animation;
        if (opacityAnimation.enable) {
            this.opacity.status = AnimationStatus.increasing;
            const opacityRange = opacityOptions.value;
            this.opacity.min = getRangeMin(opacityRange);
            this.opacity.max = getRangeMax(opacityRange);
            switch (opacityAnimation.startValue) {
                case StartValueType.min:
                    this.opacity.value = this.opacity.min;
                    this.opacity.status = AnimationStatus.increasing;
                    break;
                case StartValueType.random:
                    this.opacity.value = randomInRange(this.opacity);
                    this.opacity.status =
                        Math.random() >= 0.5 ? AnimationStatus.increasing : AnimationStatus.decreasing;
                    break;
                case StartValueType.max:
                default:
                    this.opacity.value = this.opacity.max;
                    this.opacity.status = AnimationStatus.decreasing;
                    break;
            }
            this.opacity.velocity = (opacityAnimation.speed / 100) * container.retina.reduceFactor;
            if (!opacityAnimation.sync) {
                this.opacity.velocity *= Math.random();
            }
        }
        this.sides = 24;
        let drawer = container.drawers.get(this.shape);
        if (!drawer) {
            drawer = Plugins.getShapeDrawer(this.shape);
            if (drawer) {
                container.drawers.set(this.shape, drawer);
            }
        }
        if (drawer === null || drawer === void 0 ? void 0 : drawer.loadShape) {
            drawer === null || drawer === void 0 ? void 0 : drawer.loadShape(this);
        }
        const sideCountFunc = drawer === null || drawer === void 0 ? void 0 : drawer.getSidesCount;
        if (sideCountFunc) {
            this.sides = sideCountFunc(this);
        }
        this.stroke =
            this.options.stroke instanceof Array
                ? itemFromArray(this.options.stroke, this.id, reduceDuplicates)
                : this.options.stroke;
        this.strokeWidth = this.stroke.width * container.retina.pixelRatio;
        const strokeHslColor = (_h = colorToHsl(this.stroke.color)) !== null && _h !== void 0 ? _h : this.getFillColor();
        if (strokeHslColor) {
            this.strokeColor = getHslAnimationFromHsl(strokeHslColor, (_j = this.stroke.color) === null || _j === void 0 ? void 0 : _j.animation, container.retina.reduceFactor);
        }
        this.life = this.loadLife();
        this.spawning = this.life.delay > 0;
        if (this.options.move.spin.enable) {
            const spinPos = (_k = this.options.move.spin.position) !== null && _k !== void 0 ? _k : { x: 50, y: 50 };
            const spinCenter = {
                x: (spinPos.x / 100) * container.canvas.size.width,
                y: (spinPos.y / 100) * container.canvas.size.height,
            };
            const pos = this.getPosition();
            const distance = getDistance(pos, spinCenter);
            this.spin = {
                center: spinCenter,
                direction: this.velocity.x >= 0 ? RotateDirection.clockwise : RotateDirection.counterClockwise,
                angle: this.velocity.angle,
                radius: distance,
                acceleration: getRangeValue(this.options.move.spin.acceleration),
            };
        }
        this.shadowColor = colorToRgb(this.options.shadow.color);
        if (drawer && drawer.particleInit) {
            drawer.particleInit(container, this);
        }
        for (const [, plugin] of container.plugins) {
            if (plugin.particleCreated) {
                plugin.particleCreated(this);
            }
        }
    }
    isVisible() {
        return !this.destroyed && !this.spawning && this.isInsideCanvas();
    }
    isInsideCanvas() {
        const radius = this.getRadius();
        const canvasSize = this.container.canvas.size;
        return (this.position.x >= -radius &&
            this.position.y >= -radius &&
            this.position.y <= canvasSize.height + radius &&
            this.position.x <= canvasSize.width + radius);
    }
    draw(delta) {
        const container = this.container;
        for (const [, plugin] of container.plugins) {
            container.canvas.drawParticlePlugin(plugin, this, delta);
        }
        container.canvas.drawParticle(this, delta);
    }
    getPosition() {
        return {
            x: this.position.x + this.offset.x,
            y: this.position.y + this.offset.y,
            z: this.position.z,
        };
    }
    getRadius() {
        return this.bubble.radius || this.size.value;
    }
    getMass() {
        const radius = this.getRadius();
        return (Math.pow(radius, 2) * Math.PI) / 2;
    }
    getFillColor() {
        if (this.bubble.color) {
            return this.bubble.color;
        }
        const color = getHslFromAnimation(this.color);
        if (color && (this.backColor || (this.alterType && this.alterValue !== undefined))) {
            const rolled = Math.floor(this.rollAngle / (Math.PI / 2)) % 2;
            if (rolled) {
                if (this.backColor) {
                    return this.backColor;
                }
                else if (this.alterType && this.alterValue !== undefined) {
                    return {
                        h: color.h,
                        s: color.s,
                        l: color.l + (this.alterType === AlterType.darken ? -1 : 1) * this.alterValue,
                    };
                }
            }
        }
        return color;
    }
    getStrokeColor() {
        var _a, _b;
        return (_b = (_a = this.bubble.color) !== null && _a !== void 0 ? _a : getHslFromAnimation(this.strokeColor)) !== null && _b !== void 0 ? _b : this.getFillColor();
    }
    destroy(override) {
        this.destroyed = true;
        this.bubble.inRange = false;
        if (this.unbreakable) {
            return;
        }
        this.destroyed = true;
        this.bubble.inRange = false;
        for (const [, plugin] of this.container.plugins) {
            if (plugin.particleDestroyed) {
                plugin.particleDestroyed(this, override);
            }
        }
        if (override) {
            return;
        }
        const destroyOptions = this.options.destroy;
        if (destroyOptions.mode === DestroyMode.split) {
            this.split();
        }
    }
    reset() {
        this.opacity.loops = 0;
        this.size.loops = 0;
    }
    split() {
        const splitOptions = this.options.destroy.split;
        if (splitOptions.count >= 0 && this.splitCount++ > splitOptions.count) {
            return;
        }
        const rate = getRangeValue(splitOptions.rate.value);
        for (let i = 0; i < rate; i++) {
            this.container.particles.addSplitParticle(this);
        }
    }
    calcPosition(container, position, zIndex, tryCount = 0) {
        var _a, _b, _c, _d, _e, _f;
        for (const [, plugin] of container.plugins) {
            const pluginPos = plugin.particlePosition !== undefined ? plugin.particlePosition(position, this) : undefined;
            if (pluginPos !== undefined) {
                return Vector3d.create(pluginPos.x, pluginPos.y, zIndex);
            }
        }
        const canvasSize = container.canvas.size;
        const pos = Vector3d.create((_a = position === null || position === void 0 ? void 0 : position.x) !== null && _a !== void 0 ? _a : Math.random() * canvasSize.width, (_b = position === null || position === void 0 ? void 0 : position.y) !== null && _b !== void 0 ? _b : Math.random() * canvasSize.height, zIndex);
        const radius = this.getRadius();
        const outModes = this.options.move.outModes;
        const fixHorizontal = (outMode) => {
            if (isInArray(outMode, OutMode.bounce) || isInArray(outMode, OutMode.bounceHorizontal)) {
                if (pos.x > container.canvas.size.width - radius * 2) {
                    pos.x -= radius;
                }
                else if (pos.x < radius * 2) {
                    pos.x += radius;
                }
            }
        };
        const fixVertical = (outMode) => {
            if (isInArray(outMode, OutMode.bounce) || isInArray(outMode, OutMode.bounceVertical)) {
                if (pos.y > container.canvas.size.height - radius * 2) {
                    pos.y -= radius;
                }
                else if (pos.y < radius * 2) {
                    pos.y += radius;
                }
            }
        };
        fixHorizontal((_c = outModes.left) !== null && _c !== void 0 ? _c : outModes.default);
        fixHorizontal((_d = outModes.right) !== null && _d !== void 0 ? _d : outModes.default);
        fixVertical((_e = outModes.top) !== null && _e !== void 0 ? _e : outModes.default);
        fixVertical((_f = outModes.bottom) !== null && _f !== void 0 ? _f : outModes.default);
        if (this.checkOverlap(pos, tryCount)) {
            return this.calcPosition(container, undefined, zIndex, tryCount + 1);
        }
        return pos;
    }
    checkOverlap(pos, tryCount = 0) {
        const collisionsOptions = this.options.collisions;
        const radius = this.getRadius();
        if (!collisionsOptions.enable) {
            return false;
        }
        const overlapOptions = collisionsOptions.overlap;
        if (overlapOptions.enable) {
            return false;
        }
        const retries = overlapOptions.retries;
        if (retries >= 0 && tryCount > retries) {
            throw new Error("Particle is overlapping and can't be placed");
        }
        let overlaps = false;
        for (const particle of this.container.particles.array) {
            if (getDistance(pos, particle.position) < radius + particle.getRadius()) {
                overlaps = true;
                break;
            }
        }
        return overlaps;
    }
    calculateVelocity() {
        const baseVelocity = getParticleBaseVelocity(this.direction);
        const res = baseVelocity.copy();
        const moveOptions = this.options.move;
        const rad = (Math.PI / 180) * moveOptions.angle.value;
        const radOffset = (Math.PI / 180) * moveOptions.angle.offset;
        const range = {
            left: radOffset - rad / 2,
            right: radOffset + rad / 2,
        };
        if (!moveOptions.straight) {
            res.angle += randomInRange(setRangeValue(range.left, range.right));
        }
        if (moveOptions.random && typeof moveOptions.speed === "number") {
            res.length *= Math.random();
        }
        return res;
    }
    loadShapeData(shapeOptions, reduceDuplicates) {
        const shapeData = shapeOptions.options[this.shape];
        if (shapeData) {
            return deepExtend({}, shapeData instanceof Array ? itemFromArray(shapeData, this.id, reduceDuplicates) : shapeData);
        }
    }
    loadLife() {
        const container = this.container;
        const particlesOptions = this.options;
        const lifeOptions = particlesOptions.life;
        const life = {
            delay: container.retina.reduceFactor
                ? ((getRangeValue(lifeOptions.delay.value) * (lifeOptions.delay.sync ? 1 : Math.random())) /
                    container.retina.reduceFactor) *
                    1000
                : 0,
            delayTime: 0,
            duration: container.retina.reduceFactor
                ? ((getRangeValue(lifeOptions.duration.value) * (lifeOptions.duration.sync ? 1 : Math.random())) /
                    container.retina.reduceFactor) *
                    1000
                : 0,
            time: 0,
            count: particlesOptions.life.count,
        };
        if (life.duration <= 0) {
            life.duration = -1;
        }
        if (life.count <= 0) {
            life.count = -1;
        }
        return life;
    }
}
